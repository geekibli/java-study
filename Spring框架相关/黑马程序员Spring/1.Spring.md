




## 1.BeanFactory和ApplicationContext


### 1.1 到底什么是BeanFactory

1. 它是ApplicationContext的父接口
2. 它才是Spring的核心容器, 主要的ApplicationContext 实现/组合 了它的功能



### 1.2 BeanFactory能做什么

1. 表面上只有getBean
2. 实际上控制反转、基本的依赖，注入、直至Bean的生命周期的各种功能，都由它的实现类提供
3. 它可以管理所有的bean
	

下面通过反射方式拿到beanFactory中的单例bean，当然是限定的一些类：

```java
public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        ConfigurableApplicationContext context = SpringApplication.run(TestSpringApplication.class, args);

        Field singletonObjects = DefaultSingletonBeanRegistry.class.getDeclaredField("singletonObjects");
        singletonObjects.setAccessible(true);
        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
        Map<String, Object> map = (Map<String, Object>) singletonObjects.get(beanFactory);
        map.entrySet().stream().filter(e -> e.getKey().startsWith("component"))
                .forEach(e -> {
                    System.err.println(e.getKey() + "   " + e.getValue());
                });
    }
```

![](https://oscimg.oschina.net/oscnet/up-2817b1229a9ef68d7856a9db4294f3a4bc7.png)


### 1.3 ApplicationContext比BeanFactory扩展了哪些功能


![](https://oscimg.oschina.net/oscnet/up-8f860ac2720e02b1276316a46d70ac586c3.png)


- MessageSource: 国际化语言支持能力
- ResourcePatternResolver：一些通配符的支持能力
- ApplicationEventPublisher： 事件发布能力
- EnvironmentCapable： 环境信息读取能力，系统变量和配置文件


**下面看一下MessageSource能力的展示：**

![](https://oscimg.oschina.net/oscnet/up-ad1583066a2d339fab7994f113878c1e447.png)


**context获取资源**
```java
 Resource[] resources = context.getResources("classpath:application.properties");
        for (Resource resource : resources) {
            System.err.println(resource);
        }

Resource[] resources = context.getResources("classpath*:MATE-INF/spring.factories");
        for (Resource resource : resources) {
            System.err.println(resource);
        }
```
输出结果: 
```java
class path resource [application.properties]
```


**context获取环境配置**
```java
System.err.println(context.getEnvironment().getPropertySources().get("java_home"));
System.err.println(context.getEnvironment().getProperty("java_home"));
System.err.println(context.getEnvironment().getProperty("spring.profiles.active"));
```

**事件发布与监听**
![](https://oscimg.oschina.net/oscnet/up-56692d6e9e11a092596b81ca73312c39030.png)


> **事件的好处是可以进行解耦合。**


## 2.容器的实现

### 2.1 bean的声明和定义
```java
package com.example.testspring.beans;

import lombok.Data;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

public class TestBeanFactory {
    public static void main(String[] args) {
        DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
        AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope("singleton").getBeanDefinition();
        beanFactory.registerBeanDefinition("config", beanDefinition);

        String[] beanDefinitionNames = beanFactory.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames) {
            System.out.println("beanDefinitionName : " + beanDefinitionName);
        }
    }

    @Configuration
    static class Config{
        @Bean
        public Bean1 getBean1(){
            return new Bean1();
        }

        @Bean
        public Bean2 getBean2(){
            return new Bean2();
        }
    }

    @Data
    static class Bean1 {

        public Bean1 (){
            System.out.println("init Bean1");
        }

        @Autowired
        private Bean2 bean2;

    }

    @Data
    static class Bean2 {
        public Bean2 (){
            System.out.println("init Bean2");
        }
    }

}

```
**输出结果：**

```java
beanDefinitionName : config
```

运行以上main方法，发现又有一个beanDefinition，**那为什么Bean1 , Bean2 没有打印出来呢？**


因为原始的DefaultListableBeanFactory并没有能力处理@Bean， @Configuration 这样的注解，需要借助一个工具类：

```java
public static void main(String[] args) {
        DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
        AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope("singleton").getBeanDefinition();
        beanFactory.registerBeanDefinition("config", beanDefinition);

        // 给 beanFactory 添加一些常用的后置处理器
        AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);
        
        String[] beanDefinitionNames = beanFactory.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames) {
            System.out.println("beanDefinitionName : " + beanDefinitionName);
        }
    }
```
**运行结果：**
```java
beanDefinitionName : config
beanDefinitionName : org.springframework.context.annotation.internalConfigurationAnnotationProcessor
beanDefinitionName : org.springframework.context.annotation.internalAutowiredAnnotationProcessor
beanDefinitionName : org.springframework.context.annotation.internalCommonAnnotationProcessor
beanDefinitionName : org.springframework.context.event.internalEventListenerProcessor
beanDefinitionName : org.springframework.context.event.internalEventListenerFactory
```


这里可以看到增加了一些Spring默认的beanFactory后置处理器，比如，internalConfigurationAnnotationProcessor。
这是Spring内置的注解配置类的处理器，现在它是出现在了BeanFactory中了，但是由于它还没有工作，所以，打印的结果中，我们依旧看不到Bean1,Bean2。

那么，我们需要执行这些后置处理器的后置处理方法：

```java
public static void main(String[] args) {
        DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
        AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope("singleton").getBeanDefinition();
        beanFactory.registerBeanDefinition("config", beanDefinition);

        // 给 beanFactory 添加一些常用的后置处理器
        AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);

        beanFactory.getBeansOfType(BeanFactoryPostProcessor.class)
                .values().stream()
                .forEach(beanFactoryPostProcessor -> {
                    beanFactoryPostProcessor.postProcessBeanFactory(beanFactory);
                });

        String[] beanDefinitionNames = beanFactory.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames) {
            System.out.println("beanDefinitionName : " + beanDefinitionName);
        }
    }
```

**配置类如下：**  

> 这里设置了一下bean的名字

```java
@Configuration
    static class Config{
        @Bean(name = "bean1")
        public Bean1 getBean1(){
            return new Bean1();
        }

        @Bean(name = "bean2")
        public Bean2 getBean2(){
            return new Bean2();
        }
    }
```
如果不设置 `@Bean(name = "bean1")`， 打印出来的beanDefinitionName就是方法的名字。 **getBean1**

**执行结果：**
```java
beanDefinitionName : config
beanDefinitionName : org.springframework.context.annotation.internalConfigurationAnnotationProcessor
beanDefinitionName : org.springframework.context.annotation.internalAutowiredAnnotationProcessor
beanDefinitionName : org.springframework.context.annotation.internalCommonAnnotationProcessor
beanDefinitionName : org.springframework.context.event.internalEventListenerProcessor
beanDefinitionName : org.springframework.context.event.internalEventListenerFactory
beanDefinitionName : bean1
beanDefinitionName : bean2
```

由此，我们可以看到，Bean1, Bean2是打印出来了。


### 2.2 如何使用bean

```java
System.err.println(beanFactory.getBean(Bean1.class).getBean2());
```
**运行结果：**

```java
init Bean1
null
```
可以看到，bean2的实例打印结果是空。为什么，**对象注入没有生效**。

需要bean的后置处理器 `org.springframework.context.annotation.internalAutowiredAnnotationProcessor` 来处理对应的方法来处理 @Autowired 注解。

针对Bean的声明周期的各个阶段提供扩展，比如 @Autowired, @Resource...

**把beanPostProcessor添加到beanFactory中**

```java
beanFactory.getBeansOfType(BeanPostProcessor.class).values().forEach(beanFactory::addBeanPostProcessor);

        System.err.println(beanFactory.getBean(Bean1.class).getBean2());
```
**再次查看运行结果：**

```java
21:56:59.269 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'bean1'
21:56:59.270 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'config'
init Bean1
21:56:59.309 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'bean2'
init Bean2
TestBeanFactory.Bean2()
```

**注意**：单例bean并不是beanFactory一开始就都创建好的，而是，在使用的时候，才回去初始化。

如果需要事先就初始化所有的单例对象，需要设置一个方法：

```java
beanFactory.preInstantiateSingletons();
```

### 2.3 beanFactory小结

**a. beanFactory不会主动去做的事**

1. 不会主动调用BeanFactory 后置处理器
2. 不会主动添加Bena后置处理器
3. 不会主动初始化单例bean
4. 不会解析beanFactory,还不会解析 ${} 和 #{}


**b. beanFactory后置处理器有排序的逻辑。**

> beanFactory很多基础的功能都没有主动去做。需要手动去把后置处理器设置好后才可以使用。



### 2.4 beanFactory扩展-后置处理器顺序

后置处理器的添加顺序可以看一下下面这个方法的源码 👇：

```java
org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object)
```

可以看到@Autowired的处理器加在@Resource的梳理器前面。存储的结构是 `Set<BeanDefinitionHolder> beanDefs = new LinkedHashSet(8);`

**如果一个属性注入是，即有 @Autowired 又有 @Resource注解，会怎样？** 下面尝试一下：

增加两个bean，同时加到容器中（@Configuration + @Bean）

```java
 interface Inner {
        
    }
    
@Data
static class Bean3 implements Inner {
    
    public Bean3(){
        System.out.println("init Bean3");
    }
}

@Data
static class Bean4 implements Inner {

    public Bean4(){
        System.out.println("init Bean4");
    }
}
```

如果注入的类型是 `Inner` 接口类型，会怎样？

![](https://oscimg.oschina.net/oscnet/up-de5c6eb457b97ded607e1f6abbc36af2b4c.png)

会有编译错误，提示有2个类型，Bean3 和 Bean4，没有明确要注入那个类型。

但是如果要是改一下注入的变量名称呢？

```java
 @Data
static class Bean1 {
    public Bean1() {
        System.out.println("init Bean1");
    }
    @Autowired
    private Inner bean3;
}
```
**可以看到是可以正确注入的。**

由此可以知道 @Autowired 优先按照类型注入，如果类型不能确定唯一，需要指定名称注入。

或者可以借助 注解 @Qualifier(value = "bean3") 来注入。

```java
@Data
static class Bean1 {
    public Bean1() {
        System.out.println("init Bean1");
    }
    @Autowired
    @Qualifier(value = "bean3")
    private Inner inner;
}
```

**如果对象同时添加了 @Autowired 和 @Resource(name = "bean4")，那么真实注入的对象是什么类型？**

```java
@Data
static class Bean1 {
    public Bean1() {
        System.out.println("init Bean1");
    }
    @Autowired
    @Resource(name = "bean4")
    private Inner bean3;
}
```

执行结果：

```java
TestBeanFactory.Bean3()
```

为什么呢？ 这就是beanFactory后置处理器的添加顺序了。

```java
beanFactory.getBeansOfType(BeanPostProcessor.class).values()
                .forEach(beanPostProcessor -> {
                            System.out.println("beanPostProcessor...  " + beanPostProcessor.getClass().getName());
                            beanFactory.addBeanPostProcessor(beanPostProcessor);
                        }
                );
```
查看结果：

```java
beanPostProcessor...  org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor
beanPostProcessor...  org.springframework.context.annotation.CommonAnnotationBeanPostProcessor
```

**如何控制后置处理器的添加顺序呢？**

```java
beanFactory.getBeansOfType(BeanPostProcessor.class).values()
                .stream().sorted(beanFactory.getDependencyComparator())
                .forEach(beanPostProcessor -> {
                            System.out.println("beanPostProcessor...  " + beanPostProcessor.getClass().getName());
                            beanFactory.addBeanPostProcessor(beanPostProcessor);
                        }
                );
```

执行结果：

```java
beanPostProcessor...  org.springframework.context.annotation.CommonAnnotationBeanPostProcessor
beanPostProcessor...  org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor
```

**排序是如何生效的？**

![](https://oscimg.oschina.net/oscnet/up-8e5e7d76b4ea357ea545d790b0f68f14bd0.png)

> order数值越小 优先加入。

下面是2个后置处理器的定义和构造函数：
```java

 public CommonAnnotationBeanPostProcessor() {
        this.setOrder(2147483644);
        this.setInitAnnotationType(PostConstruct.class);
        this.setDestroyAnnotationType(PreDestroy.class);
        this.ignoreResourceType("javax.xml.ws.WebServiceContext");
}


public class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware {
    protected final Log logger = LogFactory.getLog(this.getClass());
    private final Set<Class<? extends Annotation>> autowiredAnnotationTypes = new LinkedHashSet(4);
    private String requiredParameterName = "required";
    private boolean requiredParameterValue = true;
    private int order = 2147483645;
    ...
}    
```























