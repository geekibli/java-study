# 动态代理的两种方式以及区别

- JDK动态代理： 基于接口
- cglib代理：基于子类


## 基于接口的代理

- 要求：被代理类最少实现一个接口
- 提供者：JDK 
- 涉及类：Proxy
- 方法中的参数
  - ClassLoader： 类加载器 （负责加载代理对象的字节码和被代理对象使用相同的类加载器，固定写法）
  - Class[],字节码数组，负责让生成的代理对象具有和被代理对象相同的方法，写什么要看被代理对象是一个接口还是一个实现类，如果是一个接口，new Class[]{接口}
        如果是一个实现类，XXX.getClass().getInterface()
  - InvocationHandler: 一个接口，需要我们提供接口的实现，作用是用于对方法的增强，增强的代码，谁用谁写，通常是一个匿名内部类

- 基于子类的动态代理（需要导入cglib的坐标，被代理类不能是最终类，不能被final修饰）
  - 提供者：cglib（第三方类库）
  - 涉及类：Enhancer
  - 创建代理对象的方法：create
  - 方法中的参数
    - Class: 字节码对象（用于加载代理对象字节码的，写的是被代理对象的字节码，是固定写法）
    - Callback: 如何创建代理，提供增强代码，他是一个接口，需要自己实现，该接口没有方法，需要用它的子接口MethodInterceptor

